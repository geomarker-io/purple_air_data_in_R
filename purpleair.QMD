---
title: "PurpleAir Data Exploration"
subtitle: "RISE Presentation"
author: "Stephen Colegate"
date: "July 17, 2023"
format:
  html:
    output-file: "index.html"
    embed-resources: true
toc: true
toc-expand: true
toc-title: Contents
editor: visual
bibliography: purpleair.bib
number-sections: true
number-depth: 3
---

::: {.callout-note title="Before You Begin"}
Download the following files from our GitHub page. To download these files, click on the file name at the top of the page and then click **Download raw file**.

-   `purpleair.R`

-   `new_pas.R`

-   `new_pat.R`

![Click on **Download raw file** for each file posted on our GitHub page.](github_download.png){width="650"}

Once the files have been downloaded onto your computer, save all these files in one new folder. Make a mental note of the location of this folder, since you will need to reference its file path later in this tutorial. After you install both R and RStudio, clicking on any of these `.R` files should open RStudio and set your current working directory to the folder these files are located. For more information about working directories, see @sec-saveload.
:::

# Introduction {#sec-intro}

Air quality sensors have the potential to provide high spatial and temporal resolution data and their accessibility in terms of cost and ease of use [@collier-oxandale2022]. Open access to environmental data sets and related tools is possible through a stable and consistent Application Programming Interface (API) that allows software and application developers to build applications to display and report that data in transparent and meaningful ways [@feenstra2020].

In this document, we will present methods of accessing synoptic and time series data using R software with the `AirSensor` package from the PurpleAir interface [@AirSensor]. We will then explore how to visualize both the spatial (in the form of maps) and temporal (in the form of time series plots) to determine air pollution trends.

::: callout-note
This rendered HTML of all the code and relevant output is hosted online on our GitHub page, which you can access by clicking [here](https://geomarker.io/purple_air_data_in_R/). All the R code that is available in this vignette is in the `purpleair.R` file that is also hosted on our GitHub page. As you follow along with this tutorial, try running all the available R code in the `purpleair.R` file to learn how to read in your PurpleAir data and do some basic data analysis with it. You will also need the `new_pas.R` file and the `new_pat.R` file on our GitHub page to create synoptic data and time series data.
:::

## Basic Introduction to R and RStudio {#sec-introR}

::: callout-note
If you already are familiar with both R and RStudio, you may skip these sections and proceed to @sec-synoptic .
:::

R is a free, open-source software program that is available for Windows, Macs and Linux operating systems [@rcoreteam2013]. Because of this, many statisticians, biostatisticans, and data scientists have been using R to meet their data processing needs. In this tutorial, we will introduce how to install R and RStudio on your computer, try out basic R function commands, and learn how to install and load R packages. This foundation is necessary before we begin to read and explore PurpleAir sensor data.

### Installing R and RStudio {#sec-installR}

The latest version of R available as of the time of this writing is R-4.3.1. You can install R on your computer by going to <https://cran.r-project.org/> and selecting the R version that is appropriate for your operating system. Download the `base` distribution of R from the website and follow the prompts to install R on your computer.

![The Comprehensive R Archive Network (CRAN) website for downloading R.](r_site.png)

After installing R on your computer, you will also need to install [RStudio Desktop](https://posit.co/download/rstudio-desktop/) - an integrated development environment (IDE) to help data scientists be more productive with R [@rstudioteam2020a]. RStudio is a dashboard hosted by [posit](https://posit.co/) that allows ease of access to using R, especially if you are using R for the first time. The posit website link should automatically direct you to the appropriate version of RStudio you will need to download and install on your computer. Once you have both R and RStudio installed, open up the RStudio software.

![The posit site for downloading RStudio.](rstudio_site.png)

### Opening and Using R {#sec-openR}

Download the `purpleair.R` file from our [GitHub page](https://github.com/geomarker-io/purple_air_data_in_R). Make note of the file location on your computer where you save the file. It is recommended that you save the R file in a different location than your **Downloads** folder.

![Our GitHub website where all files in the document are located.](github.png)

This kind of file is called an R script. You can identify R files with the file extension name `.R`. By default, RStudio should open a `.R` file if you click on it. If your computer does not recognize the `.R` file extension, you must tell your computer to open the file using RStudio. Optionally, you can also open an `.R` file within RStudio by following these steps:

1.  Open RStudio.
2.  Click on **File** \> **Open File**. A navigation window should appear.
3.  Navigate to the file location where you saved the `purpleair.R` file.
4.  Click **Open**.

A typical layout within RStudio has four different quadrants. Starting from the top-left clockwise:

![The default RStudio layout for a typical R session.](rstudio_layout.png)

1.  **Source Pane:** This panel displays all the R scripts you have opened. Code should be written in this panel. You can save R code within the panel to work on later. Any `.R` files you open with RStudio will be displayed in this panel.
2.  **Console Pane:** This panel displays the actual R console, including all the code and output that has been conducted so far.
3.  **Environment Pane:** This panel houses several tabs. The **Environment** tab lists all the R objects and variables available during the R session. The **History** tab keeps track of all code that has been executed in the Console. More tabs may be displayed depending on the type of project you may be working on.
4.  **Output Pane:** This panel includes a file viewer, plots that have been made, list of packages available and currently loaded, help documentation, a viewer, and a presentation tab.

R code is executed one line at a time. To run a line, place your cursor on the line you wish to run in the Source Pane and click on **Run**. The line of code is then sent to the Console Pane and is executed. You can highlight multiple lines of code and run them all at once as well. Optionally, you can run lines of code by using the shortcut **CTRL + ENTER**. To get started, here is some simple lines of code:

```{r example1}
# Assign values
x <- 2    # assign the letter 'x' the value 2
y <- 9    # assign the letter 'y' the value 9
```

::: callout-tip
If the first line of code begins with the special character symbol `#`, then that line is called a comment. Comments are useful to write down what certain lines of code perform. R will not execute lines of code that begin with `#`. Likewise, R will not execute any code following the `#` symbol. As a result, the `#` symbol can also be used to grey out lines of code that maybe do not work or you wish to not execute without having to delete the entire line of code. In RStudio, comments are easily identified because the lines of code are written in green.
:::

Highlight the first line of code in the Source Pane `x <- 2`. The special character `<-` assigns the value provided on the right (`2`) to an object on the left (`x`). Hence, this line will set the variable `x` with the value of 2. The next line of code will assign the value `9` to the variable `y`. You can see that these values have been declared by clicking on the **Environment** tab in the Environment Pane.

With the variables `x` and `y` now declared, we can then use them to perform some simple operations:

```{r}
# Perform simple operations
x + y     # equivalent to '2' + '9'
sqrt(y)   # sqrt = square-root
```

::: callout-warning
R is case sensitive and name sensitive so be very careful with how you name objects, files, options, and data frames within R. For example, even though `PM25`, `pm25`, `pm2.5`, and `PM2.5` all 'appear' the same, these are classified as 4 different names. For convenience, we try to stick to lowercase letters when coding in R to avoid these discrepancies.
:::

Since `x` and `y` have been declared, R then calculates `x + y` and `sqrt(y)`. These results change depending on what the values of `x` and `y` are. As an exercise, change the values of `x` and `y` and rerun these lines again. The `sqrt()` line is a **function** - functions perform more complicated tasks within R.

::: callout-warning
Make sure you declare both `x` and `y` variables first before running `x + y` and `sqrt(y)` or else R will report an **ERROR** message.
:::

This rendered HTML of all the code and relevant output is hosted online on our GitHub page, which you can access by clicking [here](https://geomarker.io/purple_air_data_in_R/). All the R code that is available on this site is in the `purpleair.R` file. As you follow along on the site, try running all the available R code in the `purpleair.R` file to learn how to read in your PurpleAir data and do some basic data analysis with it.

::: callout-important
Make sure you always include the `.R` file extension at the end of the filename when naming and saving R scripts. RStudio will **not** add this file extension on for you automatically. If you do not include the `.R` suffix, your computer may not recognize how to open the file.
:::

R can work with data set objects, called data frames. R has a built-in data frame called `mtcars`. You can learn more information about any function or built-in data set by opening the help window using the `help()` function:

```{r help}
#| eval: false
# Display help documentation for 'mtcars'
help(mtcars)
```

We display several first rows of this new R object with the `head()` function. By default, the first 6 rows are displayed. We can change this by declaring an **option** - additional arguments you can provide in an R function to modify its behavior. For example, the option `n=10` in the `head()` function changes the number of rows to display to 10:

```{r example_print}
# Display first n=10 rows of the example cars data 
head(mtcars, n=10)
```

All options must be specified within a function. Each option is then followed by an `=` operator with the argument specified afterwards to pass onto the function. You will see more examples of using options later on.

We can reference columns within a data frame by specifying the name of the data frame, using the `$` symbol, and then the name of the column within. The `$` operator is a special character in R. It references the column name within a data frame. In the example above, if we want to only examine miles per gallon of these cars, we can reference the name of this column `mpg` within `mtcars` as the following:

```{r col_operator}
# Reference the 'mpg' column within 'mtcars'
mileage <- mtcars$mpg
head(mileage, n=20)
```

### Saving/Loading Data {#sec-saveload}

The first thing to do when starting a new R session is to set the **working directory -** a specific file path location on your computer. Whenever R fetches for a file on your computer, it will always check the working directory first. The default working directory may be different depending on how RStudio starts. You can verify the default working directory in RStudio by clicking on **Tools** \> **Global Options** and looking under the **Basic** tab in the **General** section. However, if you click on an R script on your computer, RStudio should start (by default) with the R script displayed in the Source Pane but the working directory will be the folder where the R script used to open RStudio is located. Because the working directory may change depending on how RStudio opens, it is always a good idea to set and verify the working directory before running any code.

The R package `here` can identify the current working directory of your R session based on where you saved the `purpleair.R` file. We will discuss more about R packages in the next section @sec-packages.First install the package using the `install.packages()` function with the name of the package `here` in quotes, referred to as a **character string**:

```{r install_here}
#| eval: false
# Install the 'here' package - only run this once
install.packages("here")
```

Then load the package using the `library()` function:

```{r here}
#| eval: true
# Load the 'here' package
library(here)
```

Since different operating systems have different conventions for writing out their file paths, the `here()` function makes it easy to reference your current working directory on your computer:

```{r mypath}
# Save the file path location
mypath <- here()
mypath
```

::: callout-imporant
This is the reason why it is so crucial to save all the files you download from our GitHub page into a new folder. If the files are spread out across multiple folders, R will not be able to find files or load in functions correctly. Always check the working directory of your R session first before performing any tasks or you may run into problems loading in files or saving files in the wrong location.
:::

Running this line saves the current working directory as a character string. This is convenient for referencing where the default file path location R checks for reading in files. Whenever we save data, we will use the file path `mypath` to ensure the data are saved as files in the correct file location on your computer. For example, suppose we wish to save `mtcars` in a file named `cardata.rds`. Here, the `.rds` file extension references a [**R**]{.underline} [**D**]{.underline}**ata [S]{.underline}erialization** file - a convenient way to save and read in data frame objects in R.

```{r save_file}
# Save data frame as a file
saveRDS(mtcars, file = here(mypath, "cardata.rds"))
```

We can then use the same `mypath` to load in the file as well.

```{r load_file}
# Load data frame into the R session
readRDS(file = here(mypath, "cardata.rds"))
```

::: callout-important
The `mypath` references the file path where the `purpleair.R` file is saved on your computer. If you move the `purpleair.R` file to a different location, you should also move its associated files with it too, or else you will have to manually update the file paths of each associated file. To avoid complications with problems like this, it is always a good idea to keep only the `purpleair.R` and its associated files in a folder. Moving the folder with all its contents included makes the project self-contained since the `here` package will automatically update the file paths to the new folder location.
:::

R can work with a variety of data structures besides the `.rds` format. Common structures include `.csv`, `.txt`, and `.spss`. Excel spreadsheets can also be read in by using the `readxl` package. The easiest way to import a data file for the first time is using the **Important Dataset** feature in the **Environment** Tab in the Environment Pane. All code needed to read in data files for this vignette will be provided but you may have to alter the file path locally for the code to work properly on your computer.

### Packages {#sec-packages}

R packages are extensions to the base R environment, allowing the user to import data, functions, code, documentation and objects other creators have compiled. These packages are hosted on a centralized software repository such as the [Comprehensive R Archive Network (CRAN)](https://cran.r-project.org/).

#### Installing R Packages {#sec-packages-install}

Installing packages is easy and usually requires a one-time installation process. You will need to install the following packages in an R session in order to use the following code in this vignette:

-   [`dplyr`](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf): a fast, consistent tool for working with data [@dplyr].

-   [`ggplot2`](https://cran.r-project.org/web/packages/ggplot2/ggplot2.pdf): a system for creating graphics [@ggplot2].

-   [`here`](https://cran.r-project.org/web/packages/here/here.pdf): constructs character strings consisting of file paths to reference files on your computer during an R session [@here].

-   [`MazamaCoreUtils`](https://cran.r-project.org/web/packages/MazamaCoreUtils/MazamaCoreUtils.pdf): a suite of utility functions for working with AirSensor package [@MazamaCoreUtils].

-   [`MazamaSpatialUtils`](https://cran.r-project.org/web/packages/MazamaSpatialUtils/MazamaSpatialUtils.pdf): a suite of conversion function to return spatial polygon data [@MazamaSpatialUtils].

-   [`AirSensor`](https://github.com/MazamaScience/AirSensor): package for processing and displaying data from PurpleAir [@AirSensor].

To install the `dplyr`, `ggplot2`, `here`, `devtools`, `MazamaCoreUtils` and `MazamaSpatialUtils` packages, simply use the `install.packages()` function below.

```{r install_packages}
#| eval: false
# Only run once to install (select YES to load binary packages)
install.packages(c('dplyr', 'ggplot2', 'devtools',
                   'MazamaCoreUtils', 'MazamaSpatialUtils'))
```

::: callout-caution
You may need to restart the R session in order for these packages to successfully install. If this is the case, select **Yes** when prompted to restart the R session. You may have to rerun the R code chunks again after restarting the session.
:::

::: callout-note
Some packages may need to be loaded from binary sources and compiled before installing. If this happens, a dialogue box will appear, like the one shown below.

![Answer "Yes" to install packages that need compiling.](Question.png){width="350"}

Select **Yes** to ensure the packages and their dependencies are downloaded and installed properly.
:::

Some R package depend on other R packages (called **dependencies**). Packages that depend on other packages will install these extra packages automatically if they are not already installed in the users library. You can view all the R packages installed on your computer by clicking on the **Packages** tab in RStudio on the Output Pane.

::: callout-tip
R already comes with its own packages (e.g., datasets, graphics, etc.). You do not need to install these packages, as they are already preinstalled when R is first installed.
:::

Periodically, authors of R packages will update their package to fix bugs, add more functions and data sets, and to be better compatible with the latest R software and other packages. You can use the `install.packages()` function to update (actually re-install) the package to the latest version. By default, the latest version of the package available on CRAN will be installed.

Unlike the other R packages above, the `AirSensor` package is not publicly available on CRAN (as of this writing). However, the files needed to install the package can be downloaded from [GitHub](https://github.com/MazamaScience/AirSensor). To do this, we use the `install_github()` function from the devtools package to point to the GitHub page:

```{r install_AirSensor}
#| eval: false
# Install the 'AirSensor' package - only need to run once
devtools::install_github("MazamaScience/AirSensor")
```

When the above line is executed, a list of dependencies the `AirSensor` package needs will be listed, and you will be asked to updated some or all of the packages. At the prompt, type `1` and press **ENTER** to update all the dependencies automatically.

![When prompted with a list of packages to update, type `1` and press **ENTER**.](AirSensor.png){width="500"}

All the packages listed in the console will be downloaded and installed. After these packages have been installed, the `AirSensor` package will then be downloaded and installed.

::: callout-note
It can take several minutes for all the packages to download and install on your computer. Do not run any code or stop the process by clicking on the stop sign icon in the top right of the Console Pane. Doing so can cause problems with the installation.
:::

#### Loading R Packages {#sec-packages-load}

Once R packages have been installed, you must then load the R package in the R environment. Loading in R packages allows the user to gain access to data, functions, and help documentation that comes along with the R package. To load an R package, use the function `library()` along with the package name, just as we did with the `here` package in @sec-saveload :

```{r load_packages}
#| message: false
#| warning: false
# Load required R packages
library(dplyr)
library(ggplot2)
library(here)
library(MazamaCoreUtils)
library(MazamaSpatialUtils)
library(AirSensor)
```

::: callout-tip
As shown in this example with the `here` package, a package only needs to be loaded in once per R session. Reloading a package will have no effect.
:::

You can check whether a package is successfully loaded by clicking on the **Packages** tab in the Output Pane. Loaded packages are indicated with a check mark. You can also load a package by selecting the open box next to the package name, browse package information on CRAN, and delete the package altogether from this list. Loaded packages can be unloaded by clicking on the check mark. Typically, however, packages are never unloaded, as functions that are part of a package will then become unavailable once the package is unloaded. All open packages are unloaded when R or RStudio is closed or a new R session begins.

![List of Packages installed in the Output Pane. Loaded packages are indicated with a checkmark.](packages.png){width="450"}

::: callout-warning
Unlike the installation process where the packages are installed only once, you must load these packages every time you start a new R session. When you quit your R session and start a fresh session, you must reload the R packages again.
:::

Sometimes, R will print a warning message if a package that is loaded could conflict with another package that is already loaded. This scenario appears if, for example, functions that share the same name but perform different actions from two or more packages. Functions from the latter package will mask functions that are included in packages loaded earlier by default.

![Function conflicts when loading the `dplyr` package.](conflict.png){width="450"}

To use a masked function from an earlier package, you must either unload the latter package or reference specifically the package, as in the example below:

```{r package_ref}
# Pull example sensor data from the 'AirSensor' package
sen <- AirSensor::example_sensor

# Select only the data from the example sensor data
sen.data <- sen$data # $ - references 'data' column
```

::: callout-tip
The `AirSensor` package does NOT have to be loaded for this code to work. Indeed, the `AirSensor::example_sensor` pulls the example_sensor data from the `AirSensor` package without loading the entire package. This is useful if you want to avoid loading in multiple packages that you many only use sparingly.
:::

# Synoptic (PAS) Data {#sec-synoptic}

**Synoptic data** provides a synopsis - a comprehensive view of something at a moment in time. Synoptic data takes a snapshot of data from all the PurpleAir sensors at a moment in time and uploads them to the cloud. **Spatial data** utilizes synoptic data to visualize data in different spacial locations (such as across the United States) at a given moment. Spatial data from PurpleAir sensors are stored on the cloud as **PurpleAir Synoptic (PAS)** data.

This vignette demonstrates an example workflow for exploring air quality synoptic data using the AirSensor R package and data captured by the PurpleAir air quality sensors [@callahan_pas_2023]. Spatial data from PurpleAir will be downloaded from the PurpleAir API dashboard. We will then explore the spatial data by creating maps of air quality and temperature information.

## Loading PAS Data {#sec-loadingPAS}

There are two various was to obtaining PurpleAir Synoptic (PAS) data to use with this vignette. You can create a PAS object using the latest available PurpleAir sensor data from the PurpleAir website within your R environment. This method requires the user to create an account with PurpleAir and obtain an **Application Programming Interface (API)** key unique to the user to make specific queries. You can also pull an archived PAS object of historic PurpleAir data which accomplishes the same task.

### Create a New PAS from PurpleAir Dashboard {#sec-live}

The [**PurpleAir API dashboard**](https://community.purpleair.com/t/new-api-dashboard/3981) allows users to create and manage their API keys and their usage. The site is available at [develop.purpleair.com](https://develop.purpleair.com/home). The dashboard requires a [Gmail](https://support.google.com/mail/answer/56256?hl=en) or [Google-associated](https://support.google.com/accounts/answer/27441?hl=en) account to sign in. The instructions below follow the [tutorial](https://community.purpleair.com/t/new-api-online-dashboard/3981) provided by PurpleAir.

#### Create a Project {#sec-createProject}

![The PurpleAir API dashboard for creating projects.](purpleair_projects.png)

First create a project by following these steps:

1.  Sign in to [develop.purpleair.com](https://develop.purpleair.com/home) using a Gmail or Google-associated account.

2.  Click **Projects** on the left-hand side of the page.

3.  Click on **Add** in the top right-hand corner of the page.

    ![Creating a project in the PurpleAir API dashboard.](purpleair_addproject.png){width="550"}

4.  Enter in a project name.

5.  You must allocate points to your new project. New users begin with 1 million free points that they can allocate to any project. When an API query is executed in R, points will be deducted from this allocation based on the type of data being requested. Additional points may be purchased on the PurpleAir website. More information about how points are allocated and used can be found [here](https://community.purpleair.com/t/api-pricing/4523).

6.  Click **Add**.

Once a project has been created, you can then create an API key for that project.

#### Create API Key {#sec-createAPI}

![List of active API Keys on the PurpleAir dashboard.](purpleair_apikey.png)

To obtain your unique API key follow these steps:

1.  Sign in to [develop.purpleair.com](https://develop.purpleair.com/home) using a Gmail or Google-associated account.

2.  Click **API Keys** on the left-hand side of the page.

3.  Click on **Add** in the top right-hand corner of the page.

    ![](purpleair_createkey.png){width="450"}

4.  You should see the auto-populated project name you created earlier (@sec-createProject). You can have several projects and API keys. Select the appropriate project if you have multiple projects.

5.  Select **Read** under "Type", select **Enabled** under "Status" , and leave all the other fields blank.

6.  Click **Add**.

You should then see your unique API key for the project. You can modify the allocation of points and examine the usage of the API key and its allocated points at any time.

![The unique PurpleAir API Key associated with your project.](purpleair_api.png){width="800"}

::: callout-warning
API keys are issued per user, not per sensor. Make sure that you have allocated points to the project associated with the API key before continuing on.
:::

#### Fetch and Set API Key {#sec-setAPI}

The API Key is an access token that allows you to pull PurpleAir sensor data from the cloud into your R session environment (see @sec-createAPI to learn how to create API Keys). It is not ideal to leave your API Key in a R script. If you share any of these documents that include your personal API Key with someone else, when they request PurpleAir sensor data, they will be using your points! A better solution is to save your API Key in a separate file that you keep and then provide code in the R script you are working worth that then looks for the file with your API Key and reads in the key.

In this example, suppose that the API Key for a given project is `a1b2c3d4e5f6g7h8i9j0` and the variable name to reference it is called `PurpleAir_API`.

1.  Create a new R script by clicking on **File** \> **New File** \> **R Script**.

2.  On the first line of this new blank R script, assign your PurpleAir API Key in quotes to a variable name you will then reference later. The `=` sign works just like the `<-` operator.

    ```{r API_KEY}
    #| eval: false
    # Below is the first line of the 'API_KEY.R' file
    PurpleAir_API = "a1b2c3d4e5f6g7h8i9j0"
    ```

    ::: callout-caution
    Your PurpleAir API Key must be in single-quotes or double-quotes for this to work. API Keys are recognized in R as character strings. In RStudio, character strings are written in a forest green color to easily identify character strings.
    :::

3.  Save this R file in the **same** folder as the R file you will use the API Key. In this example, we save the R file as `API_KEY.R`. Once you have saved the R file that contains your API Key, you may then close the file.

    ::: callout-caution
    Make sure you supply the `.R` file extension at the end of the file name when naming and saving the file. RStudio will **not** add this file extension on for you when you go to save the file. If you do not include the `.R` suffix, your computer may not recognize how to open the file.
    :::

4.  In the R script that you want to read in the API Key, use the `source()` function and then reference the R file (in this case, `API_KEY.R`) along with the file path `mypath` of your current working directory.

    ```{r set_API}
    #| eval: false
    # Read 'API_KEY.R' file containing the API Key
    source(mypath("API_KEY.R"))
    ```

    ::: callout-caution
    If you save your `API_KEY.R` file in a different file location on your computer than the R script that you are using to pull the API Key from, you must specify the full file path in quotes inside the `source()` function. You can use the `here` package to specify the file location where `API_KEY.R` is saved. If you save all the files in the same folder location, `mypath` should automatically contain the correct file path. See @sec-saveload for more details.
    :::

5.  If done correctly, your current R session should fetch for the appropriate R file, read it, and then save your API Key as the variable name (in this case, `PurpleAir_API`) you specified in step 2. This is a great way to save and read in your API Key without having to actually specify it. This also allows you to avoid giving out your unique API Key in the R script you are working on, protecting yourself from others that could access to the PurpleAir dashboard using your API Key.

6.  Once you have read in the variable containing the API Key (in this case, `PurpleAir_API`), you must then define how you will use the API Key with the `setAPIKey()` function. To read in PurpleAir data, we must declare that our API Key will be used to read (not write) PurpleAir data:

    ```{r PurpleAir_red}
    #| eval: false
    # Set the API Key
    setAPIKey(provider = "PurpleAir-read", key = PurpleAir_API)
    ```

    <!--# The following illustrates what setAPIKey() does when the example API Key is set. -->

    ```{r setAPIKey}
    #| echo: false
    setAPIKey(provider = "PurpleAir-read", key = "a1b2c3d4e5f6g7h8i9j0")
    ```

    The first option `provider` specifies how we will use the API Key. The second option `key` identifies the API Key variable from the `API_KEY.R` file.

7.  Verify that the API Key has been set correctly by running either the `getAPIKey()` function or the `showAPIKeys()` function:

    ```{r showAPIKeys}
    # Return all API Keys currently set
    showAPIKeys()
    ```

    This will list all the API Keys currently set in the R session. You can declare multiple API Keys if you have more than one project.

#### Read Live PAS from PurpleAir Dashboard {#sec-createPAS}

PurpleAir sensor readings are uploaded to the cloud every 120 seconds. (Every 80 seconds prior to a May 31, 2019 firmware upgrade.) Data are processed by PurpleAir and a version of the data is displayed on the PurpleAir website.

The PAS object that will be pulled from PurpleAir is a large data frame with a record for each PurpleAir sensor channel (2 channels per sensor). There are several steps that must be accomplished before the PurpleAir dashboard can be utilized to bring in sensor data. Details of these processes can be found in the Appendix (@sec-appendix).

The R script `new_pas.R` contains a function `new_pas()` that performs these background processes automatically. To load in the function, you must source the function from the `new_pas.R`, assuming it has been saved to same working directory as the `purpleair.R` script called `mypath` (@sec-saveload ).

```{r load_new_pas}
# Load in the new_pas() function from file
source(here(mypath, "new_pas.R"))
```

::: callout-tip
Before continuing, make sure you have created an API Key (@sec-createAPI) and saved it to a file (@sec-setAPI). The `new_pas()` will check if a API Key has been loaded, and if it does not find one, it will automatically search for the API Key in the R script you specify. As a result, it is not required that the API Key be set prior to running this function.
:::

The `new_pas()` function has several options available you can specify:

-   `pas_filename`: Name of the PAS file (in quotes) that will be created.

-   `folder_location`: The file path of the current root directory where the PAS will be saved to.

-   `API_filename`: The name of the file (in quotes) where the API Key is saved as the variable name `PurpleAir_API` (@sec-setAPI).

-   `folder_name`: The name of the folder (in quotes) to save spatial data needed to create the PAS, defaults to `"pas_data"`.

-   `countryCodes`: Identify the country to subset the sensor data from (in quotes); defaults to `"US"`.

-   `stateCodes`: Identify the U.S. state codes to subset the sensor data from (in quotes); defaults to `"OH"`.

-   `counties`: The US county names or 5-digit FIPS codes (in quotes), defaults to `"Hamilton"`.

-   `lookbackDays`: The number of days to look back to include only sensors with data more recent than specified; defaults to 7.

-   `location_type`: Whether outside (`0`), inside (`1`), or both (`NULL`) sensors are requested; defaults to `NULL`.

As an example, suppose we wish to create a PAS showcasing all (indoor and outdoor) PurpleAir sensor data within Hamilton County, Ohio from the past 7 days. The PAS will be created and saved in a file called `"PAS_Hamilton.rds"`. Here is how the `new_pas()` is used to achieve this:

```{r new_pas}
#| eval: false
# Create new PAS of Hamilton County, Ohio sensors from past 7 days
pas <- new_pas(pas_filename = "PAS_Hamilton.rds",
               folder_location = here(),
               API_filename = "API_KEY.R",
               folder_name = "pas_data",
               countryCodes = "US",
               stateCodes = "OH",
               counties = "Hamilton",
               lookbackDays = 7,
               location_type = NULL)
```

When this code is run, the following steps are performed in this order:

1.  The necessary packages `here`, `AirSensor`, and `MazamaSpatialUtils` are loaded if they are not already. This is to ensure all necessary functions are recognized and the rest of the steps will work.

2.  The function then checks if a PAS with `pas_filename` has already been created inside the root working directory `folder_location`. If the function finds the file, it is then loaded into the R environment. If the file does not exist, the function then asks the user whether they would like to create a new PAS using points associated with the API Key. Respond to the prompt by typing either `Y` (Yes) to continue with the steps (required if you have never created a PAS file) or `N` (No) to abort the process.

    ::: callout-tip
    If you run this function after creating a PAS file named `pas_filename`, it should detect that file and read it in automatically without calling on the PurpleAir dashboard and having to waste points recreating the PAS data.
    :::

3.  The function then sets the API Key. If you followed the steps in @sec-setAPI, `new_pas()` should verify that an API Key has already been set. If no API Key is found, the function then checks the folder specified by `folder_location` for the file `API_KEY.R`. If the function finds it, then the file is read in and the variable `PurpleAir_API` is then set as the API Key. An error message displays if the function is unable to find the file with the API Key or set the API Key. If you changed your API Key, running this function will automatically update to the new API Key.

    ::: callout-warning
    You must create and set a valid API Key before you can read data from the PurpleAir dashboard. This involves creating a project with the PurpleAir dashboard and then saving the API Key to your computer as its own file (in this case, `API_KEY.R`). The API Key is unique and is tied to the user, not the project. You do not need a new API Key each time a new PAS is created. For more information, see @sec-createAPI for creating API Keys and @sec-setAPI for saving and setting the API Key.
    :::

4.  The function next checks for various files containing spatial data on your computer. See the Appendix (@sec-appendix) for more details about these files. If you run `new_pas()` for the first time, the function goes online and downloads the necessary spatial data files and saves them inside the `folder_location` in a new folder named `folder_name`. This process is only done once - after which, the function simply checks to ensure those files are still present in that folder.

5.  The spatial data files are then initialized and brought into the R environment. The initialization is process must occur before any new PAS objects are created.

6.  After initialization, the function then proceeds to the PurpleAir dashboard and retrieves the sensor data from the cloud using the API Key. Points allocated with the PurpleAir API Key are then deducted. The data is then combined with the spatial data files to create the PAS object.

    ::: callout-important
    You must have enough points tied the API Key to complete the operation. The usage of your points varies depending on the query - click [here](https://community.purpleair.com/t/api-pricing/4523) for more details. If you do not have enough points, the operation will not be completed and an error message will be displayed. Click [here](https://api.purpleair.com/#api-keys-check-api-key) to learn more about the API Key and the data it can return. If you need to add more points, you can purchase more points to your account by clicking [here](https://community.purpleair.com/t/api-pricing/4523). Be very careful with how frequently you query the PurpleAir dashboard as you do not want to waste your points. Click [here](https://community.purpleair.com/t/api-use-guidelines/1589) to learn more about how you can optimize your points usage.
    :::

7.  The PAS object is then saved into a file named `pas_filename` in the `folder_location` folder on your computer. The next time that you run `new_pas()`, the function will check that the file is still present within the folder and read it in to your R environment for you.

### Create a New PAS from Archived Data {#sec-archive}

It is possible to load pre-generated PAS objects from a data archive specified by a URL in the `setArchiveBaseUrl()` function. Specify the name of the URL in quotes, as in the example below.

```{r setArchiveBaseUrl}
# Set location of pre-generated data files
setArchiveBaseUrl("https://airfire-data-exports.s3-us-west-2.amazonaws.com/PurpleAir/v1")
```

Archived PAS objects can be loaded very quickly with the `pas_load()` function, which obtains PAS objects from the URL archive specified with `setArchvieBaseUrl()`. When used without specifying the `datestamp` argument, `pas_load()` will obtain the most recently processed PAS object. But you can also use the `datestamp` argument inside `pas_load()` to load an archived PAS object from a specified date.

The following example loads a pre-generated PAS object from April 10, 2020 from the above archive base URL:

```{r pas_archive}
# Load a PAS object from a specific date
pas_apr10 <- pas_load(datestamp="20200410")   # '20200410' = '4-10-2020'
```

::: callout-note
In the next section, we will explore an example PAS from the `AirSensor` package. The `purpleair.R` file contains code that has been adapted from the example to this archived PAS from April 10, 2020. This additional code is not displayed in this vignette for space reasons but they accomplish the same tasks, just using a different PAS file.
:::

## Exploring Spatial Data {#sec-PAS-explore}

::: callout-note
For this demonstration, we will be using the example PAS from the `AirSensor` package to avoid long waiting times. This example PAS was generated on March 15, 2023 for outside sensors in California:

```{r pas_example}
# Example PAS from AirSensor package
pas <- AirSensor::example_pas
```

For more information about the example PAS and how it was created, run the code below. This opens up a help documentation in the Output Pane:

```{r pas_help}
#| eval: false
# Open help documentation for example PAS
help(example_pas)
```
:::

::: callout-tip
All the following R code chunks can be adapted to your own PAS object you create live (@sec-live) or archived (@sec-archive). You just need to be careful to specify the correct column and variable names. Once you work through this example PAS, you should try these commands with your own PAS files.
:::

Take a look at the first 10 rows of the PAS data frame:

```{r pas_print}
# Examine the first 10 rows
print(pas, n=10, max_footer_lines=0)
```

There are `r nrow(pas)` columns and `r ncol(pas)` columns of the data frame. Not every column and row is displayed here. Each row of the PAS object corresponds to a unique PurpleAir sensor, identified by the `deviceDeploymentID` column, at this one moment in time. Each sensor records several columns of data, which we can take a look at below:

```{r pas_col}
# Get list of column names
names(pas)
```

At a glance, the PAS has several useful columns of data we can explore. There are column recordings of temperature, relative humidity, pressure, and air quality. We are interested in PM~2.5~ (particulate matter smaller than 2.5 micrometers in diameter). There are 6 columns related to PM~2.5~ measurements. These are average PM~2.5~ measurements taken by the sensor for a certain period of time. Notice how each column starts with the prefix `pm2.5`.

We can pull only those columns that begin with this prefix and store them as a new R object. Each row corresponds to one sensor so it is also a good idea to include the `locationID` of each sensor with our new `pm25` object. The code below takes the pas R object and then uses the `select()` function to choose `locationID` that starts with `pm2.5_` as the variable name (notice the use of quotes here!). The `%>%` operator is called a pipeline operator that is available in the `dplyr` package (and others) which can accomplish this process in one execution.

::: callout-caution
The variable names of your PAS object may differ slightly from the examples provided here. Make sure you adapt the variable names such as `locationID` and `pm2.5_` exactly (case-sensitive, spelling, punctuation) so they match as specified in your PAS object.
:::

```{r pm25}
# Take a look at only PM2.5 data
pm25 <- pas %>%
  select(locationID, starts_with("pm2.5_"))
print(pm25, n=10)
```

Each row of this new `pm25_data` object corresponds to one PurpleAir sensor at a given location. Now that we have our PM~2.5~ data setup, we can now create maps to explore PM~2.5~ observations by location.

<!--# As of a recent 'knitr' update version 1.43, the leaflets are not rendering correctly in the HMTL output Quarto renders. There is a 'eval' option to turn off the leaflets if they do not display correctly or a ERROR message results when rendering the HTML output. To get them to render correctly, you must downgrade 'knitr' to version 1.42, shown below: -->

```{r knitr_down}
#| eval: false
#| echo: false
# Remove latest version of 'knitr' package (if upgraded past 1.42)
remove.packages(knitr)

# Install 'knitr' package version 1.42
require(devtools)
install_version("knitr", version = 1.42)
```

Display a map of the 1-hour average PM~2.5~ measurement for each sensor:

```{r leaflet_pm25}
#| eval: true
# Plot interactive leaflet map of 1-hour average PM2.5
pas %>%
  pas_leaflet(parameter = "pm2.5_60minute")
```

A map is shown of all the sensors with their 1 hour average PM~2.5~ measurements. The icons represent one scanner, colored based on their measurement. Clicking on one of the icons brings up the device's ID, sensor index, location, temperature, humidity, and average PM~2.5~ measurements over a 1-hour and 24-hour period.

::: callout-note
Take notice of the `sensor_index` that is displayed for each sensor. You will need a `sensor_index` to create a PAT file later in @sec-pat.
:::

PAS data can consists of many sensors, resulting in many icons to select from in the map. We may wish to filter sensors based on their readings so that only those sensors who meet our filtering criteria appear on the map. This is useful, for example, if we are interested in identifying locations with high PM~2.5~ concentrations. The `pas_filter()` function can be used to filter sensors by state (with `stateCode`) and by a filtering criterion before it is passed to the `pas_leaflet()` function. In the example below, we identify PurpleAir sensors in California who register at least a 24-hour PM~2.5~ average of 12.0 micrograms per cubic meter - the equivalent of registering a Moderate [Air Quality Index (AQI)](https://www.epa.gov/sites/default/files/2016-04/documents/2012_aqi_factsheet.pdf):

```{r leaflet_filter}
#| eval: true
# Apply filtering of sensors
pas %>%
  pas_filter(stateCode == "CA", pm2.5_24hour > 12.0) %>%
  pas_leaflet(parameter = "pm2.5_24hour")
```

The PurpleAir sensors not only record PM~2.5~ data but they also record temperature and relative humidity as well. The following example displays the (high) temperature reading of all these sensors in California that are not missing:

```{r leaflet_temperature}
#| eval: true
# Plot interactive map of temperature, removing missing data
pas %>%
  pas_filter(stateCode == "CA", !is.na(temperature)) %>%
  pas_leaflet(parameter = "temperature")
```

It is left as an exercise to plot an interactive map of relative humidity observations for these same sensors.

# Time Series (PAT) Data {#sec-timeseries}

**Time series** data provides a minute-by-minute database structure for transforming and analyzing [PurpleAir](https://www.purpleair.com/) sensor data. Unlike spatial data, which is geared for analyzing multiple sensors at one point in time, time series data focuses on a single PurpleAir sensor over time. In this manner, time series data allows the user to examine trends in air quality, temperature, and relative humidity recorded by one sensor.

## Loading PAT Data {#sec-pat}

PurpleAir sensor readings are uploaded to the cloud every 120 seconds where they are stored for download and display on the PurpleAir website. After every interval, the synoptic data is refreshed and the outdated synoptic data is then stored in a [ThingSpeak](https://thingspeak.com) database.

In order to access the ThingSpeak channel API we must first load the synoptic database object (PAS), which was discussed in @sec-createPAS. Once the PAS data frame has been loaded, we then create a **PurpleAir Time Series (PAT)** object by specifying the sensor and the dates from which to pull data from. Since this requires drawing data from the PurpleAir API dashboard, an API key (@sec-setAPI) is required to access this data to create the PAT object.

Just like the `new_pas.R` script in @sec-createPAS, the R script `new_pat.R` contains a function `new_pat()` that performs the process of creating a PAT data frame automatically. To load in the function, you must source the function from the `new_pat.R`, assuming it has been saved to same working directory as the `purpleair.R` script (@sec-saveload ).

```{r load_new_pat}
# Load in the new_pat() function from file
source(here(mypath, "new_pat.R"))
```

::: callout-warning
**A PAS file is required to create a PAT file.** Make sure you have created an PAS file @sec-createPAS and have a API Key (@sec-createAPI) saved to a file (@sec-setAPI). The `new_pat()` will check for the PAS file that you specify. If it does not detect a PAS file, the function will ask you to create a PAS file first using the `new_pas()` function before using `new_pat()`. The `new_pat()` can create a new PAT file only if a API Key has been loaded. If the function does not find one, it will automatically search for the API Key in the R script you specify. It is not required that the API Key be set prior to running this function.
:::

PAT files put emphasis on a single PurpleAir sensor. Each sensor comes with its own unique identifier. In the PAS file, this identifier is called the `sensor_index`. All measurements taken by a scanner will be authored by the `sensor_index`. If one is only interested in the measurements of a particular scanner, the PAT file can pull information from the PurpleAir dashboard for that scanner over time.

::: callout-tip
It is highly recommended that you select only one sensor from the PAS file you would like to examine over time. It is possible to create PAT files for more than one sensor, however, it is more convenient to have one PAT file represent just one PurpleAir sensor. This creates PAT files of manageable size for portability. Lots of information is collected from a single sensor and file sizes can become large if multiple sensors or multiple periods are requested. You can always read in multiple PAT files and combine them later if needed.
:::

The first step in creating the PAT file is to identify the sensor to record measurements from. In this example, the PurpleAir sensor we will study is located at Cincinnati's Fire Department Station 12, located at 3001 Spring Grove Ave, Cincinnati, OH 45225. Their PurpleAir sensor has `sensor_index` 176557.

::: callout-tip
One easy way of identifying the `sensor_index` of the PurpleAir sensor you want is to use the [online PurpleAir map](https://map.purpleair.com/1/mAQI/a10/p604800/cC0?select=176557#12.87/39.12646/-84.53578). Use this map to locate the sensor you wish to study and click on its icon. Hover your cursor over the text **Get This Widget**, revealing a pop-up window that contains the `sensor_index`.

![The `sensor_index` is usually shown in the `id` field of the widget on the [PurpleAir map](https://map.purpleair.com/1/mAQI/a10/p604800/cC0?select=176557#12.87/39.12646/-84.53578).](purpleair_map.png){width="350"}

A sure-fire way to identify a particular scanner and determine its `sensor_index` is to create a map of all the scanners inside the PAS data using `pas_leaflet()` to plot them (@sec-PAS-explore). You can then use the map to find the scanner you wish to analyze. Clicking on the icon of the scanner on the map will display information about the scanner, including its `sensor_index`.
:::

From this scanner in the PAS file `PAS_Hamilton.rds` that was created in @sec-createPAS, we wish to create a PAT file showcasing all PurpleAir sensor data from this sensor (`sensor_index=176557`) from July 1, 2023 to July 8, 2023. The PAT will be created and saved in a file called `"July_CFD12.rds"`. Here is how the `new_pat()` is used to achieve this:

```{r new_pat}
#| eval: false
# Create new PAT of one sensor from July 1 through July 8
mypat <- new_pat(pat_filename = "July_CFD12.rds",
                 folder_location = here(),
                 pas_filename = "PAS_Hamilton.rds",
                 API_filename = "API_KEY.R",
                 sensor_index = 176557,
                 start_date = "2023-07-01",
                 end_date = "2023-07-08",
                 time_zone = "UTC")
```

The `new_pat()` function has several options available you can specify:

-   `pat_filename`: Name of the PAT file (in quotes) that will be created.

-   `folder_location`: The file path of the current root directory where the PAT will be saved to.

-   `pas_filename`: Name of the PAS file (in quotes) that will be used to identify the sensor_index. A PAS file must be created before creating a PAT file. See @sec-createPAS for details.

-   `API_filename`: The name of the file (in quotes) where the API Key is saved as the variable name `PurpleAir_API` (@sec-setAPI).

-   `sensor_index`: The unique number indicator of the PurpleAir sensor you wish to analyze.

-   `start_date`: The start date to start reading data (in quotes), formatted as `"YYYY-MM-DD"`.

-   `end_date`: The end date to stop reading data (in quotes), formatted as `"YYYY-MM-DD"`.

-   `time_zone`: The Olson timezone used to interpret dates (in quotes); default is UTC.

-   `average`: Temporal averaging in minutes performed by PurpleAir; default is 0, meaning all data recorded by the sensor is instant. Values include 10, 30, 60 (hour), 360, 1440 (day).

When this code is run, the following steps are performed in this order:

1.  The necessary packages `here`, `AirSensor`, and `MazamaSpatialUtils` are loaded if they are not already. This is to ensure all necessary functions are recognized and the rest of the steps will work.

2.  The function then checks if a PAT with `pat_filename` has already been created inside the root working directory `folder_location`. If the function finds the file, it is then loaded into the R environment. If the file does not exist, the function then asks the user whether they would like to create a new PAT using points associated with the API Key. Respond to the prompt by typing either `Y` (Yes) to continue with the steps (required if you have never created a PAT file) or `N` (No) to abort the process.

    ::: callout-tip
    If you run this function after creating a PAT file named `pas_filename`, it should detect that file and read it in automatically without calling on the PurpleAir dashboard and having to waste points recreating the PAT data.
    :::

3.  The function then sets the API Key. If you followed the steps in @sec-setAPI, `new_pat()` should verify that an API Key has already been set and a message should be displayed. If no API Key is found, the function then checks the folder specified by `folder_location` for the file `API_KEY.R`. If the function finds it, then the file is read in and the variable `PurpleAir_API` is then set as the API Key. An error message displays if the function is unable to find the file with the API Key or set the API Key. If you changed your API Key within the `API_KEY.R` file, `new_pat()` will automatically update the API Key for you.

    ::: callout-warning
    You must create and set a valid API Key before you can read data from the PurpleAir dashboard. This involves creating a project with the PurpleAir dashboard and then saving the API Key to your computer as its own file (in this case, `API_KEY.R`). The API Key is unique and is tied to the user, not the project. You do not need a new API Key each time a new PAT is created. For more information, see @sec-createAPI for creating API Keys and @sec-setAPI for saving and setting the API Key.
    :::

4.  The function next checks that the required PAS file exists. If the file does not exist, the user is asked to run `new_pas()` function to create one first.

    ::: callout-tip
    If you used `new_pas()` in @sec-createPAS, then the PAS file should already exist and the new_pat() function should automatically read it in for you.
    :::

5.  The function then proceeds to the PurpleAir dashboard and retrieves all the data from the sensor from the cloud between the `start_date` and `end_date` using the API Key and the PAS file. Points allocated with the PurpleAir API Key are then deducted. The data is then combined with the spatial data files to create the PAS object.

    ::: callout-important
    You must have enough points tied the API Key to complete the operation. The usage of your points varies depending on the query - click [here](https://community.purpleair.com/t/api-pricing/4523) for more details. If you do not have enough points, the operation will not be completed and an error message will be displayed. Click [here](https://api.purpleair.com/#api-keys-check-api-key) to learn more about the API Key and the data it can return. If you need to add more points, you can purchase more points to your account by clicking [here](https://community.purpleair.com/t/api-pricing/4523). Be very careful with how frequently you query the PurpleAir dashboard as you do not want to waste your points. Click [here](https://community.purpleair.com/t/api-use-guidelines/1589) to learn more about how you can optimize your points usage.
    :::

6.  The PAT object is then saved into a file named `pat_filename` in the `folder_location` folder on your computer. The next time that you run `new_pat()`, the function will check that the file is still present within the folder and read it in to your R environment for you.

## Exploring Temporal Data {#sec-PAT-explore}

::: callout-note
All the following R code chunks can be adapted to your own PAT object you create (@sec-pat). For this demonstration, we will be using the example PAT from the AirSensor package to avoid long waiting times. The example PAT was generated for a specific sensor in Seattle, Washington between July 1, 2022 and July 8, 2022:

```{r pat_example}
# Example PAT from AirSensor package
pat <- AirSensor::example_pat
```

For more information about the example PAT, run the code below. This opens up a help documentation describing how this PAT is generated:

```{r pat_help}
#| eval: false
# Open help documentation for example PAT
help(example_pat)
```
:::

Let's explore the PAT object:

```{r pat_names}
# Explore the PAT object
pat %>%
  names()
```

The PAT object contains two dataframes:

-   `meta` - Includes one row of data that does not change over time (e.g., device location, latitude, longitude, state, county, etc.)

    ```{r pat_meta}
    # Variables that do not change with time
    names(pat$meta)
    ```

-   `data` - Includes time series data that changes with time. Each row corresponds to a snapshot of data taken from sensor_index 3515 at a certain time (in UTC) and date.

    ```{r pat_data}
    # Examine time series data
    print(pat$data, n=10)
    ```

As you can see, the PurpleAir sensor takes frequent measurements of temperature, humidity, and air quality. As the PAT object shows, these measurements change over time. We can take a look at trends for all these measurements by plotting the time series for each variable:

```{r pat_multiplot}
# Plot raw sensor data
pat %>%
  pat_multiplot(plottype="all")
```

The `plottype` option allows the user to select which variable they are interested in seeing a time series of. For PM~2.5~, the measurements are taken by two different channels, labeled **channel A** and **channel B**. These channels record PM~2.5~ data. Notice a huge spike in PM~2.5~ in both channel B and especially channel A on the night of July 4. Why do you think PM~2.5~ levels spiked here?

PAT objects can span a wide range of dates. Suppose we are only interested in time series observations during the 4th of July weekend (July 2-4, 2022). We can create another PAT object from the original one by filtering out dates covering just these three dates:

```{r pat_filterDate}
# Filter dates from the PAT object
pat_fourth <- pat %>%
  pat_filterDate(startdate=20220702, enddate=20220705)
```

Our new PAT object, `pat_forth`, only covers dates between July 2, 2022 and July 4, 2022 (notice the `enddate` is July 5 since we want to include all the time points through July 4). Now let's take a look at only PM~2.5~ values more closely during this particular weekend:

```{r pat_pm25}
# Plot only PM2.5 data covering only the 4th of July weekend 2022
pat_fourth %>%
  pat_multiPlot(plottype = "pm25_over")
```

We can see noticeable peaks on the evening of Saturday, July 2, Sunday, July 3 and especially Monday, July 4. Channel A (red) only picks up the PM~2.5~ on the evening of July 4 whereas Channel B (blue) detects increased levels of PM~2.5~ every night throughout the 4th of July holiday.

How do the values of the PurpleAir sensor compare with those from a [federal monitor](https://tools.airfire.org/monitoring/v4#!/?category=PM2.5_nowcast&centerlat=42&centerlon=-95&zoom=4)? The `pat_externalFit()` function produces a linear model between data from the PurpleAir sensor and data from the closest federal monitor [@monitori].

```{r pat_externalFit}
#| warning: false
#| message: false
# Compare sensor data with hourly data from federal monitor
pat_fourth %>%
  pat_externalFit()
```

If the PurpleAir monitor readings agrees with that of the federal monitor, then we should expect to see a high correlation, or equivalently, a high R^2^ value associated with their readings. By comparing the observations made by the PurpleAir monitor to the federal monitor, we see very little difference in PM~2.5~ readings between the two. This gives us confidence that the PurpleAir monitor is recording its PM~2.5~ observations accurately.

The `AirSensor` package also has functions to evaluate the accuracy of the measurements made by the sensor. The `pat_outliers()` function will scan the PM~2.5~ observations and identify any measurements that are considered outliers:

```{r pat_outliers}
# Identify any outliers and replace them with window median values
pat_fourth_filter <- pat_fourth %>%
  pat_outliers(replace = TRUE, showPlot = TRUE)
```

The outliers, highlighted in red, are replaced instead with window median values. We can also check the accuracy of the PM~2.5~ measurements by comparing how the two channels record PM~2.5~ via the correlation of measurements taken between channel A and channel B using `pat_internalFit()`

```{r pat_internalFit}
# Compare Channel A and Channel B of the sensors
pat_fourth_filter %>%
  pat_internalFit()
```

A simple linear regression model fits the data from channel B to data from channel A. Ideally, we would like to see a strong negative correlation between temperature and humidity and a strong positive association between channel A and channel B.

```{r pat_scatterPlotMatrix}
#| message: false
#| warning: false
# Correlations to check that sensors are properly functioning
pat_fourth_filter %>%
  pat_scatterPlotMatrix()
```

While the correlation between temperature and humidity appears fine, the correlation between channel A and channel B is not as strong as we would like. This supports our observation of several inconsistent measurements especially on the evenings of July 2-4 between the two channels.

# Acknowledgements {#sec-thanks}

Special thanks to Dr. Cole Brokamp and Dr. Patrick Ryan for allowing me to speak at this workshop.

# References

::: {#refs}
:::

# Appendix {#sec-appendix}

The following sections describes in more detail what the `new_pas()` function does behind the scenes. This information has been included here to discuss in more detail the steps outlined in @sec-createPAS. Refer to these sections if you want to understand the processes that is required to create the PAS object from PurpleAir dashboard.

## Initialization {#sec-initialization}

::: callout-note
All the tasks described in this section is accomplished automatically with the `new_pas()` function (@sec-createPAS) . As a result, this section is entirely optional and is only included for reference.
:::

The PAS requires spatial data information to be initialized first before pulling in data from the PurpleAir API dashboard. **Spatial data** is any kind of data that directly or indirectly references a specific geographical area or location. Information about the country, timezones, county, and states will be needed before pulling in PurpleAir data. The `MazamaSpatialUtils` package can be used to download and save the necessary spatial data files needed to create a PAS object. To create a new PAS object you must first properly initialize the `MazamaSpatialUtils` package by using the `initializeMazamaSpatialUtils()` function.

The initialization process must be done **before** a new PAS object is created. This may require downloading spatial data sets onto your computer. See @sec-initialization for more details. More information about the package and the spatial data that is available for download can be found [here](https://cran.r-project.org/web/packages/MazamaSpatialUtils/vignettes/MazamaSpatialUtils.html). @MazamaSpatialUtils. Make sure the package is loaded using the `library()` function.

By default, the `MazamaSpatialUtils` package comes with three built-in spatial data sets:

-   `SimpleCountries`: country outlines data.

-   `SimpleCountriesEEZ`: country outlines data including Exclusive Economic Zones over water.

-   `SimpleTimeZones`: time zone data.

`SimpleCountries` and `SimpleTimeZones` will be used when creating the PAS object. In addition to these two spatial data sets, we will also need spatial data regarding state codes and U.S. counties. These are not included in the `MazamaSpatialUtils` package. You must download the spatial data sets into a folder and then reference them later during the initialization process.

::: callout-warning
Ensure that you have the working directory set before completing these steps. In these instructions, the spatial data sets will be saved in the file path of the working directory set by `mypath` (see @sec-saveload for setting and checking your file path), where `mypath` is the character string of your current working directory. You can verify that your working directory is set by running the `here()` function:

```{r check_wd}
# Check the working directory first
mypath <- here()
mypath
```
:::

1.  Set the file directory in quotes where you will save the spacial data with the `setSpatialDataDir()` function:

    ```{r setSpatialDataDir}
    #| eval: false
    # Set the file directory to store the PAS data
    setSpatialDataDir(here(mypath, "pas_data"))
    ```

    This will create a new folder called `pas_data` inside your current working directory where the downloaded files will be saved to.

    ::: callout-caution
    Be careful how you set your file path location. R will check to make sure `mypath` is a valid file path (and it exists!) during this step. See section @sec-saveload if you are having trouble defining a valid file path.
    :::

2.  Download the state code boundaries spatial data set `NaturalEarthAdm1.rda`:

    ```{r stateCodeDataset}
    #| eval: false
    # Install spatial data containing state/province/oblast level boundaries
    installSpatialData("NaturalEarthAdm1")
    ```

    ::: callout-warning
    Downloading these spatial data sets can take a minute to process. Do not run any R code during the download process or problems may occur.
    :::

3.  Download the U.S. county level boundaries spatial data set `USCensesCounties.rda`:

    ```{r USCountiesDataset}
    #| eval: false
    # Install spatial data containing US county level boundaries
    installSpatialData("USCensusCounties")
    ```

4.  Check to ensure the download is successful by going to the file directory you set as `mypath` on your computer.

    ![](spatial_folder.png){width="450"}

    ::: callout-tip
    It is not necessary to download the `SimpleCountries` and `SimpleTimeZones` data sets. When the `initializeMazamaSpatialUtils()` function is used (described next), these spatial data sets will be loaded automatically without specifying anything.
    :::

5.  Once the two spatial data sets are loaded in a folder, initialize and bring in these spatial data sets with the `initializeMazamaSpatialUtils()` function, specifying the file path `mypath` you used along with the new folder pas_data in Step 1 with the `spatialDataDir` option:

    ```{r initializeMazamaSpatialUtils}
    #| eval: false
    # Initialize spatial data processing 
    initializeMazamaSpatialUtils(spatialDataDir = here(mypath, "pas_data"))
    ```

    ::: callout-caution
    The `initializeMazamaSpatialUtils()` function must be run **before** a new PAS data object is created. If you do not do this, an error message will result if you try to create one with the `pas_createNew()` function, asking you to initialize first.
    :::

## Details on PAS/PAT Creation {#sec-PAS-PAT}

The `pas_createNew()` function performs the following tasks behind the scenes:

1.  Download a raw dataset of the entire PurpleAir network that includes both metadata and recent PM~2.5~ averages for each deployed sensor across the globe. See `downloadParseSynopticData()` for more info.

2.  Subset and enhance the raw dataset by replacing variables with more consistent, human readable names and adding spatial metadata for each sensor including the nearest official air quality monitor. For a more in depth explanation, see `enhanceSynopticData()`.

The `pas_createNew()` function creates a new PAS object using the spatial data loaded from the `initializeMazamaSpatialUtils()` process. The function contains several options for what kind of spatial data you would like (more information can be found using the help documentation `help(pas_new)`).

The `pas_createNew()` function requires a valid API key with at least the appropriate amount of points. The API Key must be set up **prior** to running this code. See @sec-createAPI for creating an API Key on the PurpleAir API dashboard and @sec-setAPI for more details on setting an API Key.

The following example will create a brand new PAS object with up-to-the-minute data.

::: callout-important
You must have the appropriate number of points allocated to the API key in order for the PAS object to be created. If you do not have enough points on the API key, you will not be able to complete the operation.
:::

```{r pas_createNew}
#| eval: false
# Create new PAS object
pas_live <- pas_createNew(countryCodes="US",
                          stateCodes="OH",
                          counties="Hamilton",
                          lookbackDays=7,
                          location_type=NULL)
```

::: callout-note
Creating a PAS object can take up to a minute to process.
:::

Once the PAS data frame has been loaded, we then create a PAT file by specifying the sensor and the dates from which to pull data from. Since this requires drawing data from the PurpleAir API dashboard, an API key (@sec-setAPI) is required to access this data to create the PAT object.

The following example will create a brand new PAT object with up-to-the-minute data. Assuming a PAS object has been loaded (@sec-createPAS), we use it to create the PAT object with a specific `sensor_index`. Make sure you have set your API Key (@sec-setAPI) before running this code below.

::: callout-important
A PAS data frame is required to create a PAT data frame and you must have the appropriate number of points allocated to the API key in order for the PAT object to be created. If you do not have enough points on the API key, you will not be able to complete the operation.
:::

```{r pat}
#| eval: false
# Create new PAT object
pat <- pat_createNew(pas=pas,
    sensor_index="3515",    
    startdate="2022-07-01",
    enddate="2022-07-08",
    timezone="UTC",
    verbose=TRUE)
```

::: callout-note
Creating a PAT object can take up to a minute to process.
:::
